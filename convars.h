#pragma once

//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE				0 

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED		(1<<0)	// If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY	(1<<1)	// Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL			(1<<2)	// defined by the game DLL
#define FCVAR_CLIENTDLL			(1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN			(1<<4)	// Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

// ConVar only
#define FCVAR_PROTECTED			(1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY			(1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define	FCVAR_ARCHIVE			(1<<7)	// set to cause it to be saved to vars.rc
#define	FCVAR_NOTIFY			(1<<8)	// notifies players when changed
#define	FCVAR_USERINFO			(1<<9)	// changes the client's info string

#define FCVAR_PRINTABLEONLY		(1<<10)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).

#define FCVAR_GAMEDLL_FOR_REMOTE_CLIENTS		(1<<10)  // When on concommands this allows remote clients to execute this cmd on the server. 
														 // We are changing the default behavior of concommands to disallow execution by remote clients without
														 // this flag due to the number existing concommands that can lag or crash the server when clients abuse them.

#define FCVAR_UNLOGGED			(1<<11)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING	(1<<12)  // never try to print that cvar

// It's a ConVar that's shared between the client and the server.
// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
//  client, of course )
// If a change is requested it must come from the console (i.e., no remote client changes)
// If a value is changed while a server is active, it's replicated to all connected clients
#define FCVAR_REPLICATED		(1<<13)	// server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT				(1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS				(1<<15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO				(1<<16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD		(1<<17) // don't record these command in demofiles
#define FCVAR_SS_ADDED			(1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE			(1<<19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS	(1<<20)	// If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES	(1<<21)	// If this cvar changes, if forces a texture reload

#define FCVAR_NOT_CONNECTED		(1<<22)	// cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD (1<<23)	// Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_GAMECONSOLE	(1<<24) // cvar written to config.cfg on the Xbox

#define FCVAR_SERVER_CAN_EXECUTE	(1<<28)// the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY	(1<<29)// If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE	(1<<30)	// IVEngineClient::ClientCmd is allowed to execute this command. 
											// Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

#define FCVAR_ACCESSIBLE_FROM_THREADS	(1<<25)	// used as a debugging tool necessary to check material system thread convars
// #define FCVAR_AVAILABLE			(1<<26)
// #define FCVAR_AVAILABLE			(1<<27)
// #define FCVAR_AVAILABLE			(1<<31)

#define FCVAR_MATERIAL_THREAD_MASK ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD )	

enum cmd_source_t
{
	// Added to the console buffer by gameplay code.  Generally unrestricted.
	kCommandSrcCode,

	// Sent from code via engine->ClientCmd, which is restricted to commands visible
	// via FCVAR_CLIENTCMD_CAN_EXECUTE.
	kCommandSrcClientCmd,

	// Typed in at the console or via a user key-bind.  Generally unrestricted, although
	// the client will throttle commands sent to the server this way to 16 per second.
	kCommandSrcUserInput,

	// Came in over a net connection as a clc_stringcmd
	// host_client will be valid during this state.
	//
	// Restricted to FCVAR_GAMEDLL commands (but not convars) and special non-ConCommand
	// server commands hardcoded into gameplay code (e.g. "joingame")
	kCommandSrcNetClient,

	// Received from the server as the client
	//
	// Restricted to commands with FCVAR_SERVER_CAN_EXECUTE
	kCommandSrcNetServer,

	// Being played back from a demo file
	//
	// Not currently restricted by convar flag, but some commands manually ignore calls
	// from this source.  FIXME: Should be heavily restricted as demo commands can come
	// from untrusted sources.
	kCommandSrcDemoFile,

	// Invalid value used when cleared
	kCommandSrcInvalid = -1
};

class ConCommandBase
{
public:

	ConCommandBase*				m_pNext;
	bool						m_bRegistered;
	const char*					m_pszName;
	const char*					m_pszHelpString;
	int							m_nFlags;
};

class ConVar
{
private:

	enum CONVAR : int
	{
		ISCOMMAND = 1,
		ISFLAGSET = 2,
		ADDFLAGS = 3,
		REMOVEFLAGS = 4,
		GETFLAGS = 5,
		GETNAME = 6,

		GETFLOAT = 12,
		GETINT = 13,
		SETVALUECSTRING = 14,
		SETVALUEFLOAT = 15,
		SETVALUEINT = 16,
		SETVALUECOLOR = 17,
	};

private:

	struct CVValue_t
	{
		char* m_pszString;
		int							m_StringLength;

		// Values
		float						m_fValue;
		int							m_nValue;
	};

public:

	bool				IsFlagSet(int flag);
	const char*			GetName();
	void				AddFlags(int falgs);
	void				RemoveFlags(int flags);
	int					GetFlags();
	bool				IsCommand();
	float				GetFloat();
	int					GetInt();
	void				SetValue(const char* pValue);
	void				SetValue(float flValue);
	void				SetValue(int nValue);
	void				SetValue(Color value);

public:

	void*					m_vTable;				// 0x0
	ConVar*					m_pNext;				// 0x4
	bool					m_bRegistered;			// 0x8
	const char*				m_pszName;				// 0xC
	const char*				m_pszHelpString;		// 0x10
	int						m_nFlags;				// 0x14
	void*					m_callback;				// 0x18
	ConVar*					m_pParent;				// 0x1C
	const char*				m_pszDefaultValue;		// 0x20
	CVValue_t				m_Value;				// 0x24
	bool					m_bHasMin;				// 0x34
	float					m_fMinVal;				// 0x38
	bool					m_bHasMax;				// 0x3C
	float					m_fMaxVal;				// 0x40
};

class CCVar
{
private:

	enum : int
	{
		GETCVAR = 16,

		CONSOLECOLORPRITNF = 25,
		CONSOLEPRINTF = 26,
		CONSOLEDPRINTF = 27,
	};

public:

	/* use padding for console printf functions because cba
	dealing with variadic arguments */
	virtual void func0() = 0;
	virtual void func1() = 0;
	virtual void func2() = 0;
	virtual void func3() = 0;
	virtual void func4() = 0;
	virtual void func5() = 0;
	virtual void func6() = 0;
	virtual void func7() = 0;
	virtual void func8() = 0;
	virtual void func9() = 0;
	virtual void func10() = 0;
	virtual void func11() = 0;
	virtual void func12() = 0;
	virtual void func13() = 0;
	virtual void func14() = 0;
	virtual void func15() = 0;
	virtual void func16() = 0;
	virtual void func17() = 0;
	virtual void func18() = 0;
	virtual void func19() = 0;
	virtual void func20() = 0;
	virtual void func21() = 0;
	virtual void func22() = 0;
	virtual void func23() = 0;
	virtual void func24() = 0;
	virtual void ConsoleColorPrintf(const Color& clr, const char* pFormat, ...) = 0;
	virtual void ConsolePrintf(const char* pFormat, ...) = 0;
	virtual void ConsoleDPrintf(const char* pFormat, ...) = 0;

public:

	ConVar* FindVar(const char* cvar);

public:

	char pad[0x2C];									// 0x0
	ConVar* m_first_convar;							// 0x30
};

/*

Cvars are held in a list in memory 
the way we can gain access to this list is by
pattern scanning for the g_pCvar global
which is what we pass to our CVarManager class
this global is of type CCVar which has a pointer
to the first ConVar in the list and each ConVar holds a pointer
to the next so its a singly linked list

so all we have to do is traverse this list and store them 
we could use the functions provided to use from the vtable 
but this wouldnt allow us to easily unhide all hidden convars

*/

class CVarManager
{
private:

	std::vector<ConVar*> m_cvars;

	std::vector<std::pair<ConVar*, int>> m_hidden;

public:

	~CVarManager();
	CVarManager();
	CVarManager(CCVar* cvar);

	operator bool();

	ConVar* get(const char* name);

	void unhide_all();
	void rehide_all();
};